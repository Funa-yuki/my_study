\documentclass[a4paper,12pt]{jreport}
\usepackage{jgraduate}

\usepackage{textcomp}
\usepackage{listings}
\lstset{
  frame=single,
  breaklines=true,
  numbers=left,
  language=python,
  showstringspaces=false,
  upquote=true,
}

\title{Webアプリケーションを安全に\\するフレームワークの新しい機能}
\author{久保田 康平}
\university{九州大学}
\department{大学院システム情報科学府}
\major{情報知能工学専攻}

\date{令和　3年　2月}

\begin{document}

\maketitle

\begin{abstract}
本論文は，Webアプリケーションのセキュリティ機能向上を目的にしている．
そのために本論文では，Webアプリケーション開発者が実装するコードを実行時に自動的に解析し，必要ならば修正する機能をWebアプリケーションフレームワークに持たせることを提案し，実装して評価を行う．
Webアプリケーションはインターネットを通して世界中から誰でも接続でき，対話的に通信できるという特徴から様々な攻撃の対象になる．
また，インターネットの普及に伴いWebアプリケーションの重要性は増し，同様にWebアプリケーションの防御もまた重要になっている．
脆弱性攻撃は，Webアプリケーションの設計上の欠点や仕様上の問題点である脆弱性を利用する攻撃である．
脆弱性攻撃の対策の一つは，Webアプリケーションに脆弱性を作らないことであり，そのためWebアプリケーション開発者はWebアプリケーションフレームワークを利用することがある．
Webアプリケーションフレームワークは，Webアプリケーション開発において利用することが多いメソッドを持つライブラリである．
それらのメソッドを利用することで効率よくアプリケーションを開発することができる．
セキュリティ面において，Webアプリケーションフレームワークが提供するメソッドは脆弱性対策がなされているものが多い．
したがって，Webアプリケーションフレームワークを利用した方が，利用しない時と比較して効率的にセキュアなWebアプリケーションを開発しやすい．
一方で，開発者は常に完全にセキュアなコードを書くことはできないため，Webアプリケーションフレームワークを利用して，脆弱性があるWebアプリケーションを実装してしまうことがある．
その理由の一つが，Webアプリケーション開発者がWebアプリケーションフレームワークを適切に利用できないことである．
Webアプリケーション開発者が，フレームワークのメソッドが持つセキュリティ機能を正しく理解していなかったり，
セキュリティ機能を持つメソッドを知らなかったりすることによって脆弱なWebアプリケーションが実装される．
この問題に対して本論文では，Webアプリケーション開発者が実装したソースコードを修正する機能を持つWebアプリケーションフレームワークを提案する．
提案手法を実証し評価を行った結果，この機能は実装されたコードの脆弱性を一部修正でき，レスポンスタイムは提案手法を適用しなかった場合とほとんど変わらないことを確認した．
実装された修正関数の蓄積は将来のアプリケーションのセキュリティの向上に寄与できるものである．
\end{abstract}

\tableofcontents
\listoffigures
\listoftables
\newpage
\pagenumbering{arabic}

\chapter{はじめに}
%目的・提案手法
本論文は，Webアプリケーションのセキュリティ機能向上を目的にしている．
その目的の達成のために，アプリケーション開発者が実装したプログラム中の関数や引数を解析し，実行時にその関数に脆弱性があった時には修正することができるWebアプリケーションフレームワークを提案，実装し評価する．

%背景（他との比較を少し入れるwaf，フレームワークのサニタイズ）
%Webアプリケーションに対する防御手法
Webアプリケーションセキュリティは，セキュリティ分野において重要である．
インターネットの普及に伴い，Webシステムは様々な場所や階層において様々な攻撃にさらされている．
Webシステムへの攻撃のうちアプリケーション層への攻撃の多くはアプリケーションのプログラムが持つ論理的な問題が原因である．
そのためWebアプリケーション開発者は攻撃を回避するために，アプリケーションの論理的な問題や設計上の欠点である脆弱性を作らない実装をする必要がある．
一方で，Webアプリケーション開発者は常にセキュアなコードを記述することはできず，脆弱性を残す実装をすることがある．
加えてWebアプリケーション層にはセキュリティに関するプロトコルや標準的な仕様がないため，Webアプリケーションの安全性は，Webアプリケーション開発者のセキュリティに関する知識や技術に依存する．
これらのWebアプリケーションの問題を解決しセキュリティを向上するために，Webアプリケーションの自動防御手法としてWebアプリケーションファイアウォール（WAF）やWebアプリケーションフレームワークの利用などが検討されている．

%Webアプリケーションファイアウォール
WAFは，Webアプリケーションを脆弱性攻撃から保護するためのシステムである．
WAFはWebアプリケーションとクライアントの間に配置され，クライアントからのリクエストを監視し，リクエストが攻撃リクエストかどうかを検証する機能を持つ．
攻撃を検出した場合，そのリクエストを遮断もしくは無毒化することで，Webアプリケーションへの攻撃の影響を低減する．
WAFはWebアプリケーションを修正することなく，脆弱性攻撃を低減することが可能であるため，アプリケーションを直接修正できない時に有効な対策である．
一方でWAFはアプリケーションを修正しないので，アプリケーション内の脆弱性を根本的に修正できないという欠点がある．
またWAFはアプリケーション内の論理的な設計や仕様を知らないため，一部の脆弱性を対策することが難しい．
WAFは通常，特殊文字を含むリクエストを攻撃として検出する．
したがって，リクエスト内に特殊文字を含まない攻撃をWAFが検出することは難しい．

%Webアプリケーションフレームワーク
Webアプリケーションフレームワークは，Webアプリケーションを効率よく開発するために，Web開発に多用される機能を関数やメソッドとして提供するライブラリである．
自動防御手法としては，クロスサイトスクリプティング（XSS）やSQLインジェクション（SQLi）のようなインジェクション攻撃に対する入力検証と自動サニタイズという機能を提供していることがある．
自動サニタイズとは特殊文字をエスケープする機能であるサニタイズをWebアプリケーションフレームワークが行う一部のWebアプリケーションフレームワークが持つ機能である．
自動サニタイズの長所はWebアプリケーションのセキュリティの一部をWebアプリケーションフレームワークが負担することが可能なことである．
自動サニタイズによってWebアプリケーション開発者はサニタイズについて考慮することなく，セキュアなWebアプリケーションを実装することが可能になる．
一方で自動サニタイズは限定的な対策で，インジェクション攻撃ではない攻撃を対策することが難しい．

Webアプリケーションの自動防御はWebアプリケーションの論理的な設計を検証し脆弱性の影響を低減する機能を持たないため，一部の攻撃を自動的に防御することができない．
具体的には，Webアプリケーションの不適切な認証への攻撃を自動で対策する手法をWebアプリケーションフレームワークは持たない．
不適切な認証は，アプリケーションの利用者が権限を所持していると主張した時に，アプリケーションがその主張が適切かどうかを証明しない，もしくは不適切に証明する脆弱性である．

%提案手法
この問題を解決するために，本論文ではアプリケーション開発者が実装したソースコードを解析し，必要であれば修正するWebアプリケーションフレームワークであるVHF（Vulnerability Handling Framework）を提案する．
VHFは脆弱なソースコードの条件とそのソースコードを修正するプログラムを持っている．
Webアプリケーション開発者が記述したソースコードを実行開始時に静的に解析することで脆弱性を検出する．
その後，脆弱なソースコードを保護するための関数を挿入したり，安全な関数に置き換える．
挿入された関数は実行中にアプリケーションを動的に検証し，攻撃を検出すると無毒化する．
この提案手法の貢献は，Webアプリケーション開発者のソースコードを自動で修正するので，そのアプリケーションの論理的設計の不備を修正することが可能であることである．
したがってVHFは通常のWebアプリケーションフレームワークでは対策できない認証の不備に対する攻撃の低減を行うことが可能である．

%実装
VHFは実行開始時にアプリケーション開発者が実装したソースコードを修正するシステムとリクエストを処理するシステムの2つで構成されている．
ソースコードを修正するシステムはWebアプリケーション開発者が実装したソースコードを解析し修正する機能である．
VHFは実行開始時にアプリケーション開発者が実装したソースコードをフレームワーク内に格納し，その後格納したソースコードを解析・修正する．
リクエストを処理するシステムはクライアントからリクエストを受け取りレスポンスを作成して応答するシステムである．
具体的にはまず受け取ったリクエストをアプリケーションが処理しやすい形式に変更する．
次にそのリクエストを用いてレスポンスボディを作成する．
最後にレスポンスを作成する．
リクエストに基づいてレスポンスヘッダーを作成し，レスポンスボディと組み合わせてレスポンスを作成する．
作成されたレスポンスはクライアントに返される．

%評価
本論文ではWebアプリケーション開発者が実装したソースコードを解析して脆弱性の影響を緩和することが可能であるかを確認するために実験を行った．
その結果，不適切な認証とSQLインジェクションの脆弱性を修正できることを確認した．

\chapter{関連研究}
\section{論文1}
\section{論文2}
\section{論文3}

\chapter{提案手法}
VHFは，コールバック関数を解析し必要であれば修正する．
コールバック関数とはWebアプリケーションへのリクエストを基に，Webサーバー側で行う処理を記述した関数である．
VHFは，リクエストのメソッドとパスによってコールバック関数を呼び出す．
リクエストのパスとメソッドが一致するコールバック関数が存在する場合そのコールバック関数が呼び出され，その戻り値をレスポンスボディとしてクライアントに送信する．
一致するコールバック関数が存在しない場合VHFがHTTPステータスコードを404，レスポンスボディをNot Foundにしてクライアントにレスポンスを送信する．
%通信の図

VHFは実行開始時に4つの工程によってコールバック関数を修正する．
まず最初に，コールバック関数，リクエストパス，メソッドを一つの辞書式データとしてVHFに格納する．
この辞書式データはリストの一要素としてVHFに格納される．
この時点ではコールバック関数は活動中のオブジェクト，つまり実行可能なバイナリ形式のオブジェクトである．
次にコールバック関数を修正しやすくするために，VHFはコールバック関数の形式を活動中のオブジェクトから抽象構文木（Abstract Syntax Tree: AST）に変更する．
ASTは，プログラムを実行可能なバイナリ状態にする処理の途中で取得される中間生成物であり，ソースコードから実行可能なオブジェクトを生成するために必要ない部分を削除した表現である．
ASTはバイナリよりもプログラムの論理的設計を把握しやすいため，コールバック関数の解析と修正が容易である．
3つ目がコールバック関数の解析と修正である．
VHFはコールバック関数を解析し修正する脆弱性ハンドリング関数を持っている．
脆弱性ハンドリング関数は格納されたコールバック関数のリストを引数として受け取りコールバック関数のリストを返す．
脆弱性ハンドリング関数はコールバック関数のリストを受け取ると，脆弱性ハンドリング関数が持っている脆弱なコールバック関数の条件とその条件を満たすコールバック関数の修正方法に基づき脆弱性を検出・修正する．
脆弱性ハンドリング関数はコールバック関数のリストを受け取るため，コールバック関数間の論理的な設計の誤りを脆弱性の条件にすることが可能である．
具体的には，あるコールバック関数では権限を求めたページを他のコールバック関数でも同じ権限が必要になるように修正することが可能になる．
この手法を用いることで，従来では自動で対策が困難な不適切な認証の不備を低減できる．
また脆弱性ハンドリング関数は脆弱性ごとに複数の関数で実装されている．
この実装方法により新たな脆弱性が発見された時，その脆弱性の影響を低減する新たな関数を追加で実装することが可能である．
修正が終わると、VHFはコールバック関数のリストを返す．
最後にコールバック関数を実行可能なオブジェクトに変更することで，修正されたコールバック関数がリクエストを処理することが可能になる．

\chapter{実装}
この章では，VHFの実装について記述する．
VHFはPython3.7によって実装されている．
VHFは2つのシステムによって構成されている．
コールバック関数を修正するシステムとリクエストを処理するシステムである．

\section{コールバック関数の修正機能}
VHFは実行開始時にコールバック関数を解析・修正する．
この時に行われる処理はコールバック関数の格納とコールバック関数の修正の2つである．

\subsection{コールバック関数の格納}
VHFはコールバック関数を格納するためにデコレータを利用するためのメソッドとしてrouteメソッドを持つ．
実効開始時にrouteメソッドはコールバック関数をVHF内のリストに格納する．
以下のソースコードはコールバック関数の例である．
\begin{lstlisting}[caption={コールバック関数の一例}, label=code:callback, captionpos=b]
@app.route(path='^/$', method='GET')
def index(request):
  return "Hello"
\end{lstlisting}
ソースコード\ref{code:callback}の1行目がデコレータである．
デコレータは関数を修飾する関数であり，下記のソースコード\ref{code:callback2}はソースコード\ref{code:callback}と糖衣構文である．
デコレータを利用することで関数を引数にする関数の記述を簡易にしてくれる．
\begin{lstlisting}[caption={ソースコード\ref{code:callback}と糖衣な表現}, label=code:callback2, captionpos=b]
def index(request):
  return "Hello"
index = app.route(path="/", method="GET")(index)
\end{lstlisting}
ソースコード\ref{code:callback}の1行目にあるappはVHFのモジュールであり，routeはappモジュールが持つメソッドの一つである．
routeメソッドはリクエストパスとリクエストメソッドを引数としている．
ソースコード\ref{code:callback}のpathがリクエストパスの正規表現，methodがリクエストメソッド，2行目と3行目の関数が第3引数のコールバック関数である．
コールバック関数はrequestを引数として受け取る．
requestはリクエストの情報を格納している変数である．
ソースコード\ref{code:callback}の3行目は戻り値であり，この戻り値はその後レスポンスボディになる．
routeメソッドはリクエストパスとリクエストメソッドをコールバック関数と対応付けてVHFに格納する．
以下のソースコード\ref{code:route_method}がrouteメソッドの実装である．
\begin{lstlisting}[caption={routeメソッド}, label=code:route_method, captionpos=b]
class App():
  ...
    def route(self, path=None, method='GET'):
        def decorator(callback_func):
            self.router.add(method, path, callback_func)
            return callback_func
        return decorator
\end{lstlisting}
routeメソッドを実行するとrouteメソッド内部のdecorator関数を返す．
その後コールバック関数を引数としたdecorator関数が実行される．
decorator関数内のrouter.addメソッドはコールバック関数をVHFに格納するメソッドである．
decorator関数はコールバック関数を引数に取り，decorator関数内にあるリクエストメソッドとリクエストパスを一つにした辞書形式にしてVHF内に格納する．

\section{コールバック関数の修正}
VHFに格納された時点ではコールバック関数は活動中のオブジェクト，つまり機械語である．
機械語を解析・修正するのは容易ではないため格納されたコードを一度修正しやすい形式に変換する．
具体的には，活動中のオブジェクトをASTに変換する．
Pythonは，ASTを処理するライブラリとしてastモジュールを提供している．
このモジュールは，ソースコードをASTに変換したりASTを探索したりするメソッドを持っている．
parseメソッドはastモジュール内にある，ソースコードをASTに変換するメソッドである．
parseメソッドはソースコードを引数として受け取るため，格納された時点での活動中のオブジェクトとしてのコールバック関数を受け取ることはできない．
したがって，一度コールバック関数をソースコードに変換したのち，parseメソッドを利用してコールバック関数をソースコードからASTに変換する．

その後VHFはASTになったコールバック関数を解析・修正する．
VHFはコールバック関数を修正する関数として脆弱性ハンドリング関数を実装している．
脆弱性ハンドリング関数はASTであるコールバック関数のリストを引数に取り，解析・修正されたASTであるコールバック関数のリストを返す．
脆弱性ハンドリング関数は特定のASTのノードを脆弱性とみなしている．
脆弱性ハンドリング関数は脆弱性と判断したノードがコールバック関数内にあるかを解析し，検出されたノードは脆弱性ハンドリング関数内で定義したノードの修正方法に基づいて修正される．
脆弱性ハンドリング関数は脆弱性ごとに分割して構成されており，VHFにASTであるコールバック関数をひとまとめにしたリストとして格納されている．
コールバック関数のリストは順に脆弱性ハンドリング関数によって解析・修正される．
脆弱性ハンドリング関数は分割して構成されているので，新しい脆弱性が見つかるたび追加の脆弱性ハンドリング関数を実装することが可能である．
この実装により，既存の脆弱性ハンドリング関数を変更せずにその脆弱性を対策することが可能である．

最後にコールバック関数を活動中のオブジェクトに変更する．
ASTを実行可能な形式に変更するために，exec()関数を利用する．
これにより，コールバック関数は活動中のオブジェクトとなり，リクエストを処理することが可能になる．

\section{リクエスト処理システム}
リクエスト処理システムはリクエストを基にコールバック関数を呼び出しレスポンスを作成するシステムである．
このシステムはリクエスト情報の取得，コールバック関数の呼び出し，リクエストの作成の3つの機能から構成されている．

\subsection{リクエスト情報の取得}
リクエスト情報の取得は，クライアントからのHTTPリクエストを取得し，アプリケーションが処理しやすいように加工する機能である．

\subsection{コールバック関数の呼び出し}

\subsection{レスポンスの作成}

\chapter{実験}
本研究では二つの実験を行った．
一つ目に脆弱性ハンドリング関数が脆弱性の影響を低減したかどうかの評価を行った．
二つ目に脆弱性ハンドリング関数が実装されたことによる実行開始時のオーバーヘッドの計測を行った．

\section{脆弱性の影響低減評価}
脆弱性ハンドリング関数を実装することにより脆弱なコールバック関数を修正し，脆弱性攻撃への影響を低減することが可能か評価した．
本実験では二つの脆弱性を持つアプリケーションを一つ実装した．
実装されたアプリケーションが持つ二つの脆弱性はSQLiと不適切な認証のである．
この脆弱性に対して，それぞれ脆弱性ハンドリング関数を実装した．
その後，ローカル上でアプリケーションを実行し，攻撃することで脆弱性攻撃の影響を低減できたか評価した．
本実験は以下の環境で行われた．
Mac OS X El Capitan 10.11.6, Intel Core i5(2.95GHz), メインメモリ8GB.
以下には，それぞれの脆弱なコールバック関数と脆弱性ハンドリング関数を記述する．

\subsection{SQLiを持つコールバック関数の修正}
SQLiはリクエスト内の値を利用して直接クエリを作成することで起こる脆弱性である．
リクエストに特殊文字を挿入することで，アプリケーション開発者が意図していない命令がデータベースで実行される．
これにより，データベースが改ざんされたり不正に削除されたりする．
下記のコールバック関数はSQLiの脆弱性を持つコールバック関数である．
\begin{lstlisting}[caption={SQLi脆弱性を持つコールバック関数}, label=code:sqli_callback, captionpos=b]
@app.route("^/access$", "POST")
def access(request):
  import sqlite3
  conn = sqlite3.connect("test.sqlite3")
  cur = conn.cursor()
  action = request.forms.get('action')
  name = request.forms.get('name')
  password = request.forms.get('password')
  query = '{action} * from user'.format(action=action)
  if action='select':
    query += " where name = '{name}' and password = 'password'".format(name=name, password=password)
    cur.execute(query)
    data = cur.fetchone()
    return tmpl("access.html", action='select',tel=data[2],mail_address=data[3])
  else:
    cur.execute(query)
  return tmpl("access.html", action=action)
\end{lstlisting}
上記のソースコード\ref{code:sqli_callback}の1行目は，コールバック関数を格納するメソッドである．
リクエストパスが"/access"でリクエストメソッドがPOSTの時，このコールバック関数が呼び出される．
2行目以降のaccess()関数がコールバック関数である．
ソースコード\ref{code:sqli_callback}の3行目から5行目がデータベースと接続する準備である．
3行目でリレーショナルデータベースとしてsqlite3をインポートしている．
4行目でデータベースに接続し，5行目でカーソルを宣言している．
その後ソースコード\ref{code:sqli_callback}の6行目から8行目では，クエリを作成するために必要な情報をリクエストパラメータから取り出している．
取り出される変数はaction, name, passwordである．
actionはSQLのコマンド，nameはユーザー名，passwordはユーザーのパスワードである．
ソースコード\ref{code:sqli_callback}の9行目と11行目でこれらの変数を利用してクエリを作成する．
ソースコード\ref{code:sqli_callback}の12行目で作成したクエリがデータベースで実行される．

上記のソースコード\ref{code:sqli_callback}は，リクエストパラメータを直接利用してクエリを作成しているためSQLi脆弱性を持っている．
このソースコードに対して，下記の脆弱性ハンドリング関数を実装した．

hogehoge

\subsection{不適切な認証を持つコールバック関数の修正}

\subsection{結果}

\section{オーバーヘッドの評価}
VHFは実行開始時にコールバック関数を解析するためWebアプリケーションの実行よりも，
\subsection{結果}


\chapter{考察}

\chapter{おわりに}


\end{document}
