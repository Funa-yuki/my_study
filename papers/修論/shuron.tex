\documentclass[a4paper,12pt]{jreport}
\usepackage{jgraduate}

\usepackage{textcomp}
\usepackage{listings}
\lstset{
  frame=single,
  breaklines=true,
  numbers=left,
  language=python,
  showstringspaces=false,
  upquote=true,
}

\title{Webアプリケーションを安全に\\するフレームワークの新しい機能}
\author{久保田 康平}
\university{九州大学}
\department{大学院システム情報科学府}
\major{情報知能工学専攻}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
本論文は，Webアプリケーションのセキュリティ機能向上を目的にしている．
そのために本論文では，Webアプリケーション開発者が実装するコードを実行時に自動的に解析し，必要ならば修正する機能をWebアプリケーションフレームワークに持たせることを提案し，実装して評価を行う．
Webアプリケーションはインターネットを通して世界中から誰でも接続でき，対話的に通信できるという特徴から様々な攻撃の対象になる．
また，インターネットの普及に伴いWebアプリケーションの重要性は増し，同様にWebアプリケーションの防御もまた重要になっている．
脆弱性攻撃は，Webアプリケーションの設計上の欠点や仕様上の問題点である脆弱性を利用する攻撃である．
脆弱性攻撃の対策の一つは，Webアプリケーションに脆弱性を作らないことであり，そのためWebアプリケーション開発者はWebアプリケーションフレームワークを利用することがある．
Webアプリケーションフレームワークは，Webアプリケーション開発において利用することが多いメソッドを持つライブラリである．
それらのメソッドを利用することで効率よくアプリケーションを開発することができる．
セキュリティ面において，Webアプリケーションフレームワークが提供するメソッドは脆弱性対策がなされているものが多い．
したがって，Webアプリケーションフレームワークを利用した方が，利用しない時と比較して効率的にセキュアなWebアプリケーションを開発しやすい．
一方で，開発者は常に完全にセキュアなコードを書くことはできないため，Webアプリケーションフレームワークを利用して，脆弱性があるWebアプリケーションを実装してしまうことがある．
その理由の一つが，Webアプリケーション開発者がWebアプリケーションフレームワークを適切に利用できないことである．
Webアプリケーション開発者が，フレームワークのメソッドが持つセキュリティ機能を正しく理解していなかったり，
セキュリティ機能を持つメソッドを知らなかったりすることによって脆弱なWebアプリケーションが実装される．
この問題に対して本論文では，Webアプリケーション開発者が実装したソースコードを修正する機能を持つWebアプリケーションフレームワークを提案する．
提案手法を実証し評価を行った結果，この機能は実装されたコードの脆弱性を一部修正でき，レスポンスタイムは提案手法を適用しなかった場合とほとんど変わらないことを確認した．
実装された修正関数の蓄積は将来のアプリケーションのセキュリティの向上に寄与できるものである．
\end{abstract}

\tableofcontents
\listoffigures
\listoftables
\newpage
\pagenumbering{arabic}

\chapter{はじめに}
%目的・提案手法
本論文は，Webアプリケーションのセキュリティ機能向上を目的にしている．
その目的の達成のために，アプリケーション開発者が実装したプログラム中の関数や引数を解析し，実行時にその関数に脆弱性があった時には修正することができるWebアプリケーションフレームワークを提案，実装し評価する．

%背景（他との比較を少し入れるwaf，フレームワークのサニタイズ）
%Webアプリケーションに対する防御手法
Webアプリケーションセキュリティは，セキュリティ分野において重要である．
インターネットの普及に伴い，Webシステムは様々な場所や階層において様々な攻撃にさらされている．
Webシステムへの攻撃のうちアプリケーション層への攻撃の多くはアプリケーションのプログラムが持つ論理的な問題が原因である．
そのためWebアプリケーション開発者は攻撃を回避するために，アプリケーションの論理的な問題や設計上の欠点である脆弱性を作らない実装をする必要がある．
一方で，Webアプリケーション開発者は常にセキュアなコードを記述することはできず，脆弱性を残す実装をすることがある．
加えてWebアプリケーション層にはセキュリティに関するプロトコルや標準的な仕様がないため，Webアプリケーションの安全性は，Webアプリケーション開発者のセキュリティに関する知識や技術に依存する．
これらのWebアプリケーションの問題を解決しセキュリティを向上するために，Webアプリケーションの自動防御手法としてWebアプリケーションファイアウォール（WAF）やWebアプリケーションフレームワークの利用などが検討されている．

%Webアプリケーションファイアウォール
WAFは，Webアプリケーションを脆弱性攻撃から保護するためのシステムである．
WAFはWebアプリケーションとクライアントの間に配置され，クライアントからのリクエストを監視し，リクエストが攻撃リクエストかどうかを検証する機能を持つ．
攻撃を検出した場合，そのリクエストを遮断もしくは無毒化することで，Webアプリケーションへの攻撃の影響を低減する．
WAFはWebアプリケーションを修正することなく，脆弱性攻撃を低減することが可能であるため，アプリケーションを直接修正できない時に有効な対策である．
一方でWAFはアプリケーションを修正しないので，アプリケーション内の脆弱性を根本的に修正できないという欠点がある．
またWAFはアプリケーション内の論理的な設計や仕様を知らないため，一部の脆弱性を対策することが難しい．
WAFは通常，特殊文字を含むリクエストを攻撃として検出する．
したがって，リクエスト内に特殊文字を含まない攻撃をWAFが検出することは難しい．

%Webアプリケーションフレームワーク
Webアプリケーションフレームワークは，Webアプリケーションを効率よく開発するために，Web開発に多用される機能を関数やメソッドとして提供するライブラリである．
自動防御手法としては，クロスサイトスクリプティング（XSS）やSQLインジェクション（SQLi）のようなインジェクション攻撃に対する入力検証と自動サニタイズという機能を提供していることがある．
自動サニタイズとは特殊文字をエスケープする機能であるサニタイズをWebアプリケーションフレームワークが行う一部のWebアプリケーションフレームワークが持つ機能である．
自動サニタイズの長所はWebアプリケーションのセキュリティの一部をWebアプリケーションフレームワークが負担することが可能なことである．
自動サニタイズによってWebアプリケーション開発者はサニタイズについて考慮することなく，セキュアなWebアプリケーションを実装することが可能になる．
一方で自動サニタイズは限定的な対策で，インジェクション攻撃ではない攻撃を対策することが難しい．

Webアプリケーションの自動防御はWebアプリケーションの論理的な設計を検証し脆弱性の影響を低減する機能を持たないため，一部の攻撃を自動的に防御することができない．
具体的には，Webアプリケーションの不適切な認証への攻撃を自動で対策する手法をWebアプリケーションフレームワークは持たない．
不適切な認証は，アプリケーションの利用者が権限を所持していると主張した時に，アプリケーションがその主張が適切かどうかを証明しない，もしくは不適切に証明する脆弱性である．

%提案手法
この問題を解決するために，本論文ではアプリケーション開発者が実装したソースコードを解析し，必要であれば修正するWebアプリケーションフレームワークであるVHフレームワーク（Vulnerability Handling Framework）を提案する．
VHフレームワークは脆弱なソースコードの条件とそのソースコードを修正するプログラムを持っている．
Webアプリケーション開発者が記述したソースコードを実行開始時に静的に解析することで脆弱性を検出する．
その後，脆弱なソースコードを保護するための関数を挿入したり，安全な関数に置き換える．
挿入された関数は実行中にアプリケーションを動的に検証し，攻撃を検出すると無毒化する．
この提案手法の貢献は，Webアプリケーション開発者のソースコードを自動で修正するので，そのアプリケーションの論理的設計の不備を修正することが可能であることである．
したがってVHフレームワークは通常のWebアプリケーションフレームワークでは対策できない認証の不備に対する攻撃の低減を行うことが可能である．

%実装
実効開始時にVHフレームワークはWebアプリケーション開発者のソースコードに4つの工程を行う．
まずはじめに，Webアプリケーション開発者が実装したソースコードを実行可能な状態でVHフレームワークに格納する．
次に，格納されたソースコードを解析しやすいよう形式に修正する．
第三に形式を変更したソースコードを解析し修正する．
そして最後に修正されたソースコードを実行可能な状態に戻す．

%評価
本論文ではWebアプリケーション開発者が実装したソースコードを解析して脆弱性の影響を緩和することが可能であるかを確認するために実験を行った．
その結果，不適切な認証とSQLインジェクションの脆弱性を修正できることを確認した．

\chapter{関連研究}
\section{論文1}
\section{論文2}
\section{論文3}

\chapter{提案手法}
VHフレームワークは，コールバック関数を解析し必要であれば修正する．
コールバック関数とはWebアプリケーションへのリクエストを基に，Webサーバー側で行う処理を記述した関数である．
VHフレームワークは，リクエストのメソッドとパスによってコールバック関数を呼び出す．
リクエストのパスとメソッドが一致するコールバック関数が存在する場合そのコールバック関数が呼び出され，その戻り値をレスポンスボディとしてクライアントに送信する．
一致するコールバック関数が存在しない場合VHフレームワークがHTTPステータスコードを404，レスポンスボディをNot Foundにしてクライアントにレスポンスを送信する．
%通信の図

VHフレームワークは実行開始時に4つの工程によってコールバック関数を修正する．
まず最初に，コールバック関数，リクエストパス，メソッドを一つの辞書式データとしてVHフレームワークに格納する．
この辞書式データはリストの一要素としてVHフレームワークに格納される．
この時点ではコールバック関数は活動中のオブジェクト，つまり実行可能なバイナリ形式のオブジェクトである．
次にコールバック関数を修正しやすくするために，VHフレームワークはコールバック関数の形式を活動中のオブジェクトから抽象構文木（Abstract Syntax Tree: AST）に変更する．
ASTは，プログラムを実行可能なバイナリ状態にする処理の途中で取得される中間生成物であり，ソースコードから実行可能なオブジェクトを生成するために必要ない部分を削除した表現である．
ASTはバイナリよりもプログラムの論理的設計を把握しやすいため，コールバック関数の解析と修正が容易である．
3つ目がコールバック関数の解析と修正である．
VHフレームワークはコールバック関数を解析し修正する脆弱性ハンドリング関数を持っている．
脆弱性ハンドリング関数は格納されたコールバック関数のリストを引数として受け取りコールバック関数のリストを返す．
脆弱性ハンドリング関数はコールバック関数のリストを受け取ると，脆弱性ハンドリング関数が持っている脆弱なコールバック関数の条件とその条件を満たすコールバック関数の修正方法に基づき脆弱性を検出・修正する．
脆弱性ハンドリング関数はコールバック関数のリストを受け取るため，コールバック関数間の論理的な設計の誤りを脆弱性の条件にすることが可能である．
具体的には，あるコールバック関数では権限を求めたページを他のコールバック関数でも同じ権限が必要になるように修正することが可能になる．
この手法を用いることで，従来では自動で対策が困難な不適切な認証の不備を低減できる．
また脆弱性ハンドリング関数は脆弱性ごとに複数の関数で実装されている．
この実装方法により新たな脆弱性が発見された時，その脆弱性の影響を低減する新たな関数を追加で実装することが可能である．
修正が終わると、VHフレームワークはコールバック関数のリストを返す．
最後にコールバック関数を実行可能なオブジェクトに変更することで，修正されたコールバック関数がリクエストを処理することが可能になる．

\chapter{実装}
この章では，VHフレームワークの実装について記述する．
VHフレームワークはPython3.7によって実装されている．
VHフレームワークは2つのシステムによって構成されている．
コールバック関数を修正するシステムとリクエストを処理する機能である．

\section{コールバック関数の修正機能}
VHフレームワークは実行開始時にコールバック関数を解析・修正する．
この時に行われる処理はコールバック関数の格納とコールバック関数の修正の2つである．

\subsection{コールバック関数の格納}
VHフレームワークはコールバック関数を格納するためにデコレータを利用する．
以下のソースコードはコールバック関数の例である．
\begin{lstlisting}[caption={コールバック関数の一例}, label=code:callback, captionpos=b]
@app.route(path='/', method='GET')
def index(request):
  return "Hello"
\end{lstlisting}
1行目がデコレータである．
デコレータは関数を修飾する関数であり，下記の2つのソースコードは糖衣構文である．
\begin{lstlisting}[caption={Pythonデコレータのコード例}, label=code:decorator, captionpos=b]
@decorator
  def func():
    ...
\end{lstlisting}
\begin{lstlisting}[caption={\ref{code:decorator}と糖衣構文なソースコード例}, label=code:decorator2, captionpos=b]
def func():
  ...
func = decorator(func)
\end{lstlisting}
デコレータを利用することで，関数を引数にする関数の記述を簡易にしてくれる．
ソースコード\ref{code:callback}の1行目にあるappはVHフレームワークのモジュールであり，routeはappモジュールが持つメソッドの一つである．
routeメソッドはリクエストパスとリクエストメソッド，コールバック関数を引数としている．
ソースコード\ref{code:callback}のpathがリクエストパス，methodがリクエストメソッド，2行目と3行目の関数が第3引数のコールバック関数である．
ソースコード\ref{code:callback}の2行目と3行目がコールバック関数である．
コールバック関数はrequestを引数として受け取る．
requestはリクエストの情報を格納している変数である．
ソースコード\ref{code:callback}の3行目は戻り値であり，この戻り値はその後レスポンスボディになる．
routeメソッドはリクエストパスとリクエストメソッドをコールバック関数と対応付けてVHフレームワークに格納する．
以下がrouteメソッドの実装である．
\begin{lstlisting}[caption={routeメソッド}, label=code:route_method, captionpos=b]
import app
\end{lstlisting}
%hogehoge

\section{コールバック関数の修正}
コールバック関数の修正のために．

\subsection{コールバック関数の修正}

\section{リクエスト処理機能}

%5つのシステム（モジュール）で構成
VHフレームワークは5つのシステムで構成される．


\chapter{実験}

\chapter{結果}

\chapter{考察}

\chapter{おわりに}


\end{document}
